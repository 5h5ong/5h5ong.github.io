{"version":3,"sources":["component/PopupNotification.tsx","hooks/useInput.ts","libs/copyToClipboard.ts","libs/korToEngDictionary.ts","libs/korArrayToEng.ts","libs/separateKor.ts","App.tsx","reportWebVitals.ts","index.tsx"],"names":["PopupNotification","displayText","className","useInput","initialValue","useState","value","setValue","onChange","e","target","copyToClipboard","textToCopy","navigator","clipboard","writeText","korToEngDictionary","ㅂ","ㅈ","ㄷ","ㄱ","ㅅ","ㅛ","ㅕ","ㅑ","ㅐ","ㅔ","ㅁ","ㄴ","ㅇ","ㄹ","ㅎ","ㅗ","ㅓ","ㅏ","ㅣ","ㅋ","ㅌ","ㅊ","ㅍ","ㅠ","ㅜ","ㅡ","ㅃ","ㅉ","ㄸ","ㄲ","ㅆ","ㅒ","ㅖ","korArrayToEng","korArray","map","korElement","join","separateKor","originalKor","Hangul","App","korInput","convertedText","setConvertedText","isRippling","setIsRippling","displayNotification","setDisplayNotification","displayPopupNotification","setDisplayPopupNotification","resultDivRef","useRef","x","y","coords","setCoords","useEffect","converted","setTimeout","placeholder","style","left","top","ref","onClick","rect","current","getBoundingClientRect","clientX","clientY","getCoords","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.cc00255d.chunk.js","sourcesContent":["import React from \"react\";\nimport \"./PopupNotification.css\";\n\ninterface PopupNotificationProps {\n  displayText: string;\n}\n\n/**\n * 짠하고 나오는 안내\n * @param displayText 보여줄 텍스트\n */\nconst PopupNotification = ({ displayText }: PopupNotificationProps) => {\n  return <div className=\"popup-notification\">{displayText}</div>;\n};\n\nexport default PopupNotification;\n","import React, { useState } from \"react\";\n\nconst useInput = (initialValue = \"\") => {\n  const [value, setValue] = useState(initialValue);\n  const onChange = (\n    // textarea도 같이 처리해주기 위해서 \"React.ChangeEvent<HTMLTextAreaElement>\" 부분을 추가함\n    e:\n      | React.ChangeEvent<HTMLInputElement>\n      | React.ChangeEvent<HTMLTextAreaElement>\n  ) => {\n    setValue(e.target.value);\n  };\n  return { value, onChange, setValue };\n};\n\nexport type useInputReturnType = ReturnType<typeof useInput>;\nexport default useInput;\n","/**\n *  텍스트를 클립보드로 복사함\n * @param textToCopy 클립보드로 복사될 텍스트\n */\nconst copyToClipboard = (textToCopy: string) => {\n  navigator.clipboard.writeText(textToCopy);\n};\n\nexport default copyToClipboard;\n","/**\n * 한글 -> 영어 딕셔너리\n */\nexport const korToEngDictionary: { [index: string]: string } = {\n  ㅂ: \"q\",\n  ㅈ: \"w\",\n  ㄷ: \"e\",\n  ㄱ: \"r\",\n  ㅅ: \"t\",\n  ㅛ: \"y\",\n  ㅕ: \"u\",\n  ㅑ: \"i\",\n  ㅐ: \"o\",\n  ㅔ: \"p\",\n  ㅁ: \"a\",\n  ㄴ: \"s\",\n  ㅇ: \"d\",\n  ㄹ: \"f\",\n  ㅎ: \"g\",\n  ㅗ: \"h\",\n  ㅓ: \"j\",\n  ㅏ: \"k\",\n  ㅣ: \"l\",\n  ㅋ: \"z\",\n  ㅌ: \"x\",\n  ㅊ: \"c\",\n  ㅍ: \"v\",\n  ㅠ: \"b\",\n  ㅜ: \"n\",\n  ㅡ: \"m\",\n  ㅃ: \"Q\",\n  ㅉ: \"W\",\n  ㄸ: \"E\",\n  ㄲ: \"R\",\n  ㅆ: \"T\",\n  ㅒ: \"O\",\n  ㅖ: \"P\",\n};\n","import { korToEngDictionary } from \"./korToEngDictionary\";\n\n/**\n * 한글이 들어있는 배열을 영어로 바꿈 ㅁ -> a\n * @param korArray 분리된 한글이 들어있는 배열\n * @return 변경된 영어 문장\n */\nconst korArrayToEng = (korArray: string[]) => {\n  // 한글 배열을 영어 배열로 변경\n  // 만약, 딕셔너리에 값이 존재하지 않으면 한글 배열에 들어있던 값 그대로 사용\n  const engArray = korArray.map(\n    (korElement) => korToEngDictionary[korElement] ?? korElement\n  );\n\n  // 영어 배열을 공백없이 문자열로 이어붙임\n  return engArray.join(\"\");\n};\n\nexport default korArrayToEng;\n","import * as Hangul from \"hangul-js\";\n\n/**\n * 한글 문장을 하나씩 때어 배열로 반환함\n * @param originalKor 입력된 한글 문장\n * @returns 배열로 분리된 한글 문장\n */\nconst separateKor = (originalKor: string) => {\n  const separatedKorArray = Hangul.disassemble(originalKor);\n  return separatedKorArray;\n};\n\nexport default separateKor;\n","import React, { useEffect, useRef, useState } from \"react\";\nimport \"./App.css\";\nimport PopupNotification from \"./component/PopupNotification\";\nimport useInput from \"./hooks/useInput\";\nimport copyToClipboard from \"./libs/copyToClipboard\";\nimport korArrayToEng from \"./libs/korArrayToEng\";\nimport separateKor from \"./libs/separateKor\";\n\nfunction App() {\n  const korInput = useInput();\n  const [convertedText, setConvertedText] = useState(\"\");\n  // ripple effect 생성 제어\n  const [isRippling, setIsRippling] = useState<boolean>(false);\n  // notification 표시 제어\n  const [displayNotification, setDisplayNotification] = useState<boolean>(\n    false\n  );\n  // popup notification 표시 제어\n  const [displayPopupNotification, setDisplayPopupNotification] = useState(\n    false\n  );\n  // result div의 ref(ripple effect를 위해 사용됨)\n  const resultDivRef = useRef<HTMLDivElement>(null);\n  // result div 클릭 좌표 저장(ripple effect를 위해 사용됨)\n  const [coords, setCoords] = useState<{ x: number; y: number }>({\n    x: -1,\n    y: -1,\n  });\n\n  // 입력된 한글 문장을 분리\n  useEffect(() => {\n    const converted = korArrayToEng(separateKor(korInput.value));\n    setConvertedText(converted);\n  }, [korInput.value]);\n  // 인풋에 아무 것도 없다면 notification 표시 안함\n  useEffect(() => {\n    if (korInput.value) {\n      setDisplayNotification(true);\n    } else {\n      setDisplayNotification(false);\n    }\n  }, [korInput.value]);\n  // ripple effect 제어\n  useEffect(() => {\n    if (coords.x !== -1 && coords.y !== -1) {\n      setIsRippling(true);\n      setTimeout(() => {\n        setIsRippling(false);\n      }, 1000);\n    } else {\n      setIsRippling(false);\n    }\n  }, [coords]);\n\n  // 클릭 시 만들어진 영어 텍스트를 클립보드로 복사\n  const engTextOnClick = () => {\n    copyToClipboard(convertedText);\n\n    // 복사됨을 알려주는 팝업 .5s 동안 띄움\n    setDisplayPopupNotification(true);\n    setTimeout(() => {\n      setDisplayPopupNotification(false);\n    }, 1000);\n  };\n\n  // result div의 좌표와 클릭된 좌표를 얻어 ripple effect가\n  // 생길 부분을 계산\n  const getCoords = (e: React.MouseEvent<HTMLDivElement, MouseEvent>) => {\n    // result div의 좌표(좌측 상단)\n    const rect =\n      resultDivRef.current && resultDivRef.current.getBoundingClientRect();\n    // ripple element가 표시될 좌표 계산\n    if (rect) {\n      setCoords({ x: e.clientX - rect.left, y: e.clientY - rect.top });\n    }\n  };\n\n  return (\n    <div className=\"container\">\n      {displayPopupNotification && (\n        <PopupNotification displayText=\"😎 복사됨!\" />\n      )}\n      {/* input */}\n      <div className=\"input-container\">\n        <input\n          className=\"input\"\n          placeholder=\"변환할 문장을 입력해주세요.\"\n          value={korInput.value}\n          onChange={korInput.onChange}\n        />\n      </div>\n      {/* text-result */}\n      {/* 텍스트가 없거나 isRippling이 true일 때 클릭 이벤트를 없앤 */}\n      {/* .text-result를 보여줘 ripple effect가 이상하게 보이지 않게 함 */}\n      <div className=\"text-result-wrapper\">\n        {!korInput.value || isRippling ? (\n          <div className=\"text-result\">\n            {isRippling && (\n              <div\n                className=\"test-dot\"\n                style={{\n                  // ripple effect의 원 반지름을 빼줘야 클릭된 위치에서 표시됨\n                  left: coords.x - 35,\n                  top: coords.y - 35,\n                }}\n              />\n            )}\n            {convertedText}\n          </div>\n        ) : (\n          <div\n            className=\"text-result\"\n            ref={resultDivRef}\n            onClick={(e) => {\n              engTextOnClick();\n              getCoords(e);\n            }}\n          >\n            {isRippling && (\n              <div\n                className=\"test-dot\"\n                style={{\n                  // ripple effect의 원 반지름을 빼줘야 클릭된 위치에서 표시됨\n                  left: coords.x - 35,\n                  top: coords.y - 35,\n                }}\n              />\n            )}\n            {convertedText}\n          </div>\n        )}\n        {/* notification */}\n        {displayNotification && (\n          <div className=\"notification\">클릭해서 복사할 수 있어요!</div>\n        )}\n      </div>\n    </div>\n  );\n}\n\nexport default App;\n","import { ReportHandler } from 'web-vitals';\n\nconst reportWebVitals = (onPerfEntry?: ReportHandler) => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from \"react\";\nimport \"./index.css\";\nimport ReactDOM from \"react-dom\";\nimport App from \"./App\";\nimport reportWebVitals from \"./reportWebVitals\";\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById(\"root\")\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}